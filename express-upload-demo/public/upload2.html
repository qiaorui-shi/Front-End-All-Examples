<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <input type="file" id="uploadRef" />
    <button onclick="handleUpload()">ä¸Šä¼ </button>
    <button onclick="mergeChunkRequest()">åˆå¹¶</button>

    <script src="./javascripts/saprk-md5.min.js"></script>
    <script>
      const uploadForm = document.querySelector("#uploadRef");

      //fileæ–‡ä»¶ï¼Œ chunkFileSizeåˆ†ç‰‡æ–‡ä»¶å¤§å°
      function createChunks(file, chunkFileSize = 1024 * 1024) {
        let startIndex = 0;
        const chunks = [];
        while (startIndex < file.size) {
          chunks.push(file.slice(startIndex, startIndex + chunkFileSize));
          startIndex += chunkFileSize;
        }

        // è®¡ç®—æ¯ä¸ªåˆ†ç‰‡çš„ Hash
        return Promise.all(
          chunks.map(async (chunk) => {
            return {
              chunkHash: await calculateHash(chunk),
              chunk
            };
          })
        );
      }

      //è®¡ç®—æ–‡ä»¶çš„hashå€¼
      function calculateHash(file) {
        return new Promise((resolve, reject) => {
          const fileReader = new FileReader();
          fileReader.readAsArrayBuffer(file);
          fileReader.onload = function (e) {
            if (!e.target?.result) {
              reject(new Error("æ–‡ä»¶è¯»å–å¤±è´¥"));
              return;
            }
            const spark = new SparkMD5.ArrayBuffer();
            spark.append(e.target.result);
            resolve(spark.end());
          };
          fileReader.onerror = function () {
            reject(new Error("æ–‡ä»¶è¯»å–å¤±è´¥"));
          };
        });
      }

      async function handleUpload() {
        const file = uploadForm.files[0];
        // è®¡ç®—å®Œæ•´æ–‡ä»¶çš„hash
        const fileHash = await calculateHash(file);
        // è·å–æ–‡ä»¶åˆ‡ç‰‡å’Œå¯¹åº”çš„hashå€¼
        const chunksFile = await createChunks(file);
        // ç»„è£…åˆ‡ç‰‡å¯¹åº”çš„è¡¨å•æ•°æ®
        const fileData = chunksFile.map((item, index) => {
          const formData = new FormData();
          formData.append("fileHash", fileHash);
          formData.append("chunkHash", item.chunkHash + "-" + index);
          formData.append("chunk", item.chunk);
          console.log("ğŸš€ ~ fileData ~ formData:", formData);
          return formData;
        });

        // ç”Ÿæˆæ‰€æœ‰è¯·æ±‚å‡½æ•°
        const taskPool = fileData.map(
          (formData) => () =>
            fetch("http://localhost:3000/upload2/upload", {
              method: "POST",
              body: formData
            })
        );
        // æ§åˆ¶è¯·æ±‚å¹¶å‘æ•°é‡
        await concurRequest(taskPool, 6);
        mergeChunkRequest(fileHash);
      }

      // ä¸Šä¼ å®Œæˆåè¿›è¡Œåˆå¹¶æ“ä½œ
      function mergeChunkRequest(fileHash) {
        const params = {
          fileHash: "da91cb40ca5019af5a75ec96b606ba9f",
          fileName: "da91cb40ca5019af5a75ec96b606ba9f"
        };
        fetch("http://localhost:3000/upload2/mergeChunk", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(params)
        }).then((res) => {});
      }

      // æ§åˆ¶è¯·æ±‚å¹¶å‘
      function concurRequest(taskPool, max) {
        return new Promise((resolve) => {
          if (taskPool.length === 0) {
            resolve([]);
            return;
          }
          const results = [];
          let index = 0;
          let count = 0;
          const request = async () => {
            if (index === taskPool.length) return;
            const i = index;
            const task = taskPool[index];
            index++;
            try {
              results[i] = await task();
            } catch (err) {
              results[i] = err;
            } finally {
              count++;
              if (count === taskPool.length) {
                resolve(results);
              }
              request();
            }
          };
          const times = Math.min(max, taskPool.length);
          for (let i = 0; i < times; i++) {
            request();
          }
        });
      }
    </script>
  </body>
</html>
